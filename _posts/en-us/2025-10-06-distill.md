---
layout: post
title: "Learning Journal — 2025-10-06 (y/m/d): WebAssembly History & Concepts"
description: "Notes, reflections, and rough experiments on WebAssembly, asm.js, and related tooling."
tags: [learning, webassembly, webdev, research, thesis]
giscus_comments: false
date: 2025-10-06
featured: false
slug: learning-2025-10-05-webassembly
authors:
  - name: Andrei Gulin
toc:
  - name: Overview
  - name: Key Takeaways
  - name: Background & References
  - name: Relevance & Connections
  - name: Confusions & Questions
  - name: Action Plan
  - name: Reflections
  - name: Raw Notes
---

# Learning Journal — 2025-10-06: WebAssembly History & Concepts

---

## Overview

I spent roughly 2 hours understanding how webassembly appeared. Descovered `emscripten` and `asm.js`. Interesting stuff. Helped me understand why webassembly is the way it is.
I feel like I spent some time jumping between pages, sometimes losing focus, but overall I got a bit clearer picture.

---

## Key Takeaways

1. **Emscripten**

   * At first compiles `C/C++` to `JS` was original idea
   * Dude that worked in `Mozilla` understood that `this compilation` produced some parts that were identical to after parsing `JS` code
     it was `C/C++` to `JS`, after that he asked to make `C/C++` to `asm.js` which is a subset of `JS` that is easier to optimize
   * When they got approval to make their `asm.js` on all browsers, they decided to really optimize it and make it a `binary format` which is `WebAssembly`

   * Funny note: Emscripten name is a reference to Simpsons episode, where they used `embiggen` word which is a made up word

2. **asm.js**

   * Basically a subset of `JS` optimized for performance. Mozilla created it to run compiled C/C++ code on browsers.
   * Limitation: still parsed as `JS` → startup slower, more memory overhead.

3. **WebAssembly**

   * Binary format, sandboxed, runs in browsers.
   * I still don’t fully get memory management between Wasm and JS — will test later.
   * Its interesting to me that maybe its easier to debug asm.js than webassembly, because its still `JS` after all, and then just recompile to `Wasm` and run it

---

## Background & References

* [why web assembly is fast](https://hacks.mozilla.org/2017/02/what-makes-webassembly-fast/)
* [nice blog, BUT its old and it feels like that people who wrote it didn't know much about asm.js or emscripten](https://www.nutrient.io/blog/webassembly-a-new-hope/)
* [REALLY FUCKING NICE ARTICLE](https://spectrum.ieee.org/webassembly-will-finally-let-you-run-highperformance-applications-in-your-browser)

---

## Relevance & Connections

* Shows why performance-oriented languages can exist in browsers.
* I don’t see strong parallels with earlier topics yet, but I can imagine future Rust → WebAssembly exercises.
* Might relate to future projects: WASI, server-side Wasm, maybe WebGPU integration.

---

## Confusions & Questions

* How exactly does the browser execute Wasm? Is it JIT or AOT compiled?
* How even browser execute JS? 
* Memory: is it shared with JS or copied?
* Debugging: can i debug wasm through debugging it in asm.js and then recompiling to wasm?
* Security: no fucking clue yet.

---

## Action Plan

1. Review asm.js examples to understand translation pipeline.
2. Track all questions above and see what resources answer them.

---

## Reflections

* Writing this journal helps me consolidate thoughts and actually think after I learnt something.

---

## Raw Notes

> didn't do this time, need to do next time

---

## Summary

No summary
